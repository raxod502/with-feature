;;; with-feature.el --- Better with-eval-after-load. -*- lexical-binding: t -*-

;; Copyright (C) 2017 Radon Rosborough

;; Author: Radon Rosborough <radon.neon@gmail.com>
;; Homepage: https://github.com/raxod502/with-feature
;; Keywords: extensions
;; Created: 6 Aug 2017

;;; Commentary:

;; This package is under construction.

;;; Code:

(defvar with-feature-recursive-autoload nil
  "Used to detect autoloading failure.
After an autoload stub has attempted to load the real definition,
it binds this variable before calling itself. That way, if the
real definition wasn't loaded, the stub will be called again and
it can tell what has happened.

Don't bind this yourself unless you like playing with
velociraptors.")

(defmacro with-feature-autoload
    (func feature &optional interactive prepare-func args)
  "Autoload function FUNC from given FEATURE.
INTERACTIVE tells whether the function should be interactive. If
PREPARE-FUNC is supplied, then it is called with ARGS and it
should return code that makes FEATURE available in the current
Emacs session. That code is not evaluated until the autoload is
triggered."
  (if prepare-func
      `(let* ((load-list-item '(defun . ,func))
              (already-loaded (member load-list-item current-load-list)))
         (defun ,func (&rest args)
           ,(format "Deferred autoload generated by `with-feature'.
This function is a stub created in order to autoload a function
provided by a feature that may not yet be available (%S).

\(fn ...)" feature)
           ,@(when interactive
               `((interactive)))
           (cond
            ((bound-and-true-p with-feature-recursive-autoload)
             (error "Loading feature `%S' did not define function `%S'"
                    ',feature ',func))
            (,(apply prepare-func args)
             (if (require ',feature nil 'noerror)
                 (let ((with-feature-recursive-autoload t))
                   (if (called-interactively-p 'any)
                       (call-interactively ',func)
                     (apply ',func args)))
               (error "Deferred autoloading failed: feature `%S' unavailable"
                      ',feature)))
            (t (user-error "Feature loading unsuccessful, aborting")))))
    `(autoload ,func ,(symbol-name feature) nil ,interactive)))

(defmacro with-feature-eval-or-defer
    (form &optional lazy-prepare-func &rest args)
  "Eval FORM immediately or wrap in runtime eval.
Deferral can only happen if LAZY-PREPARE-FUNC is provided. If it
is provided, it is called with ARGS, and a nil return value means
to defer evaluation until runtime."
  (if (and lazy-prepare-func (null (apply lazy-prepare-func args)))
      `(eval ',form)
    ,form))

(defun with-feature-normalize-pseudo-plist (pseudo-plist)
  "Normalize a pseudo-plist into a regular plist.
The keywords of the pseudo-plist are taken to the keys of the
regular plist. The elements between keywords in the pseudo-plist
are collected into lists, which become the values of the regular
plist. If two keywords are adjacent, the first one has no effect.
Elements coming before any keywords have a key of nil in the
regular plist. If a keyword is specified more than once, the
latter overrides the former."
  (let ((keyword nil)
        (elts nil)
        (plist nil))
    (dolist (elt pseudo-plist plist)
      (if (keywordp elt)
          (progn
            (when elts
              (setq plist (plist-put plist keyword (nreverse elts))))
            (setq keyword elt)
            (setq elts nil))
        (push elt elts)))))

;;;; Closing remarks

(provide 'with-feature)

;;; with-feature.el ends here

;; Local Variables:
;; outline-regexp: ";;;;* "
;; End:
