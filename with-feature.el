;;; with-feature.el --- Better with-eval-after-load. -*- lexical-binding: t -*-

;; Copyright (C) 2017 Radon Rosborough

;; Author: Radon Rosborough <radon.neon@gmail.com>
;; Homepage: https://github.com/raxod502/with-feature
;; Keywords: extensions
;; Created: 6 Aug 2017

;;; Commentary:

;; This package is under construction.

;;; Code:

;;;; Libraries

(require 'cl-lib)
(require 'subr-x)

;;;; Miscellaneous

(defvar with-feature-recursive-autoload nil
  "Used to detect autoloading failure.
After an autoload stub has attempted to load the real definition,
it binds this variable before calling itself. That way, if the
real definition wasn't loaded, the stub will be called again and
it can tell what has happened.

Don't bind this yourself unless you like playing with
velociraptors.")

(defun with-feature-autoload
    (func feature &optional interactive prepare-func args)
  "Return code autoloading function FUNC from given FEATURE.
FUNC and FEATURE are symbols. INTERACTIVE tells whether the
function should be interactive. If PREPARE-FUNC is supplied, then
it is called with ARGS and it should return code that makes
FEATURE available in the current Emacs session. That code is not
evaluated until the autoload is triggered."
  (if prepare-func
      ;; We use a dynamically generated (per-function) symbol here
      ;; because one deferred autoload might trigger another after
      ;; being loaded, and that would not signal anything out of the
      ;; ordinary.
      (let ((recursive-autoload
             (intern (format "with-feature-recursive-autoload-%S"
                             func))))
        `(let* ((load-list-item '(defun . ,func))
                (already-loaded (member load-list-item current-load-list)))
           (defun ,func (&rest args)
             ,(format "Deferred autoload generated by `with-feature'.
This function is a stub created in order to autoload a function
provided by a feature that may not yet be available (%S).

\(fn ...)" feature)
             ,@(when interactive
                 `((interactive)))
             (cond
              ((bound-and-true-p ,recursive-autoload)
               (error "Loading feature `%S' did not define function `%S'"
                      ',feature ',func))
              (,(apply prepare-func args)
               (if (require ',feature nil 'noerror)
                   (let ((,recursive-autoload t))
                     (if (called-interactively-p 'any)
                         (call-interactively ',func)
                       (apply ',func args)))
                 (error "Deferred autoloading failed: feature `%S' unavailable"
                        ',feature)))
              (t (user-error "Feature loading unsuccessful, aborting"))))))
    `(autoload ,func ,(symbol-name feature) nil ,interactive)))

(defun with-feature-eval-or-defer
    (form &optional lazy-prepare-func &rest args)
  "Return code evalling FORM immediately or wrapping in runtime eval.
Deferral can only happen if LAZY-PREPARE-FUNC is provided. If it
is provided, it is called with ARGS, and a nil return value means
to defer evaluation until runtime."
  (if (and lazy-prepare-func (null (apply lazy-prepare-func args)))
      `(eval ',form)
    form))

(defun with-feature-normalize-pseudo-plist (pseudo-plist)
  "Normalize a PSEUDO-PLIST into a regular plist.
The keywords of the pseudo-plist are taken to the keys of the
regular plist. The elements between keywords in the pseudo-plist
are collected into lists, which become the values of the regular
plist. If two keywords are adjacent, the first one has no effect.
Elements coming before any keywords have a key of nil in the
regular plist. If a keyword is specified more than once, the
latter overrides the former."
  (let ((keyword nil)
        (elts nil)
        (plist nil))
    (dolist (elt pseudo-plist plist)
      (if (keywordp elt)
          (progn
            (when elts
              (setq plist (plist-put plist keyword (nreverse elts))))
            (setq keyword elt)
            (setq elts nil))
        (push elt elts)))))

(defvar with-feature-keyword-alist
  '((:init . 0)
    (:config . 1000))
  "Alist of keywords that have special significance in `with-feature'.
The keys are keywords, and the values are numbers (not
necessarily integers) representing their relative ordering. When
the keywords in a `with-feature' form are processed, they are
processed in ascending order of the ordering numbers. If two
keywords have equal ordering, then the one specified earlier in
the alist is processed first.")

(defun with-feature-keywords ()
  "Return a list of the keywords in `with-feature-keyword-alist', in order.
This means the keywords at the beginning of the list have the
lowest ordering number, and are processed first by
`with-feature'."
  (thread-first with-feature-keyword-alist
    (copy-sequence)
    (cl-stable-sort #'< :key #'cdr)
    (thread-last (mapcar #'car))))

(defun with-feature-maybe-progn (forms)
  "Wrap FORMS in a `progn' if necessary, else return the single form.
If no FORMS, return nil."
  (pcase (length forms)
    (0 nil)
    (1 (car forms))
    (_ `(progn ,@forms))))

(defun with-feature-codegen (state)
  "Derive code for an expanded `with-feature' form from the STATE."
  (with-feature-maybe-progn
   `(,@(plist-get state :init)
     ,@(when-let ((config (plist-get state :config)))
         `((with-eval-after-load ',(plist-get state :feature)
             ,@config))))))

(defun with-feature-keyword-handler (keyword)
  "Return the symbol for the function that handles given KEYWORD."
  (thread-first keyword
    (symbol-name)
    (substring 1)
    (thread-last (format "with-feature-keyword-%S"))
    (intern)))

(defmacro with-feature-defkeyword
    (keyword order arglist &optional docstring &rest body)
  "Define a keyword handler and register it in `with-feature-keyword-alist'.
KEYWORD is the keyword to register, and ORDER is a number
representing its precedence relative to other keywords in
`with-feature-keyword-alist'. ARGLIST, DOCSTRING, and BODY are as
in `defun'.

If the keyword has already been registered, this overrides its
previous handler and resets its order in
`with-feature-keyword-alist'.

KEYWORD must be a literal keyword, but ORDER may be computed."
  (unless (keywordp keyword)
    (error "Non-keyword registered as keyword: `%S'" keyword))
  (unless (stringp docstring)
    (setq docstring nil)
    (setq body (cons docstring body)))
  `(progn
     (defun ,(with-feature-keyword-handler keyword) ,arglist
       ,@(when docstring
           (list docstring))
       ,@body)
     (map-put with-feature-keyword-alist ,keyword ,order)))

;;;; Closing remarks

(provide 'with-feature)

;;; with-feature.el ends here

;; Local Variables:
;; outline-regexp: ";;;;* "
;; End:
