;;; with-feature.el --- Better with-eval-after-load. -*- lexical-binding: t -*-

;; Copyright (C) 2017 Radon Rosborough

;; Author: Radon Rosborough <radon.neon@gmail.com>
;; Homepage: https://github.com/raxod502/with-feature
;; Keywords: extensions
;; Created: 6 Aug 2017

;;; Commentary:

;; This package is under construction.

;;; Code:

;;;; Libraries

(require 'cl-lib)
(require 'map)
(require 'subr-x)

;;;; Utility functions
;;;;; Property lists

(defun with-feature-plist-remove (plist prop)
  "Remove a value from a property list.
PLIST is a property list and PROP is the key for the value to
remove. This is distinct to setting the value to nil using
`plist-put'. Keys are compared to PROP using `eq'.

The new plist is returned; the original is not modified."
  (cl-loop for (key val) on plist by #'cddr
           unless (eq key prop)
           collect key and collect val))

(defun with-feature-normalize-pseudo-plist (pseudo-plist)
  "Normalize a PSEUDO-PLIST into a regular plist.
The keywords of the pseudo-plist are taken to the keys of the
regular plist. The elements between keywords in the pseudo-plist
are collected into lists, which become the values of the regular
plist. If two keywords are adjacent, the first one has no effect.
Elements coming before any keywords have a key of nil in the
regular plist. If a keyword is specified more than once, the
latter overrides the former."
  (let ((keyword nil)
        (elts nil)
        (plist nil))
    (dolist (elt pseudo-plist plist)
      (if (keywordp elt)
          (progn
            (when elts
              (setq plist (plist-put plist keyword (nreverse elts))))
            (setq keyword elt)
            (setq elts nil))
        (push elt elts)))))

;;;;; Signals

(defmacro with-feature-error (string &rest args)
  "Report an `error' from `with-feature'.
STRING and ARGS are as for `error'.

This is a macro so that it can be used at runtime without
`with-feature' loaded."
  `(error (format "with-feature: %s" ,string) ,@args))

;;;;; Code generation

(defvar with-feature-recursive-autoload nil
  "Used to detect autoloading failure.
After an autoload stub has attempted to load the real definition,
it binds this variable before calling itself. That way, if the
real definition wasn't loaded, the stub will be called again and
it can tell what has happened.

Don't bind this yourself unless you like playing with
velociraptors.")

(defun with-feature-autoload
    (func feature &optional interactive prepare-func args)
  "Return code autoloading function FUNC from given FEATURE.
FUNC and FEATURE are symbols. INTERACTIVE tells whether the
function should be interactive. If PREPARE-FUNC is supplied, then
it is called with ARGS and it should return code that makes
FEATURE available in the current Emacs session. That code is not
evaluated until the autoload is triggered."
  (if prepare-func
      ;; We use a dynamically generated (per-function) symbol here
      ;; because one deferred autoload might trigger another after
      ;; being loaded, and that would not signal anything out of the
      ;; ordinary.
      (let ((recursive-autoload
             (intern (format "with-feature-recursive-autoload-%S"
                             func))))
        `(let* ((load-list-item '(defun . ,func))
                (already-loaded (member load-list-item current-load-list)))
           (defun ,func (&rest args)
             ,(format "Deferred autoload generated by `with-feature'.
This function is a stub created in order to autoload a function
provided by a feature that may not yet be available (%S).

\(fn ...)" feature)
             ,@(when interactive
                 `((interactive)))
             (cond
              ((bound-and-true-p ,recursive-autoload)
               (error "Loading feature `%S' did not define function `%S'"
                      ',feature ',func))
              (,(apply prepare-func args)
               (if (require ',feature nil 'noerror)
                   (let ((,recursive-autoload t))
                     (if (called-interactively-p 'any)
                         (call-interactively ',func)
                       (apply ',func args)))
                 (error "Deferred autoloading failed: feature `%S' unavailable"
                        ',feature)))
              (t (user-error "Feature loading unsuccessful, aborting"))))))
    `(autoload ,func ,(symbol-name feature) nil ,interactive)))

(defun with-feature-eval-or-defer
    (form &optional lazy-prepare-func &rest args)
  "Return code evalling FORM immediately or wrapping in runtime eval.
Deferral can only happen if LAZY-PREPARE-FUNC is provided. If it
is provided, it is called with ARGS, and a nil return value means
to defer evaluation until runtime."
  (if (and lazy-prepare-func (null (apply lazy-prepare-func args)))
      `(eval ',form)
    form))

(defun with-feature-maybe-progn (forms)
  "Wrap FORMS in a `progn' if necessary, else return the single form.
If no FORMS, return nil."
  (pcase (length forms)
    (0 nil)
    (1 (car forms))
    (_ `(progn ,@forms))))

;;;; Middleware handling

;;;###autoload
(defvar with-feature-middleware-alist nil
  "Alist of middleware to be applied by `with-feature'.
The keys are symbols; for symbol `foo' there should be a function
`with-feature-middleware/foo' which applies the middleware. The
values are numbers (not necessarily integers) that specify the
relative ordering of the middleware. Middleware with lower
ordering is applied first; in the case of a tie, the middleware
appearing first in the alist is applied first.

When `with-feature' receives its arguments, it passes them as a
list to the first middleware function, and threads the return
value through all remaining middleware functions. The eventual
expansion of the macro is the return value of the last middleware
function.

See also `with-feature-defmiddleware'.")

(defun with-feature-middlewares ()
  "Return a list of the middleware in `with-feature-keyword-alist', in order.
This means the middleware at the beginning of the list have the
lowest ordering, and are applied first by `with-feature'."
  (thread-first with-feature-middleware-alist
    (copy-sequence)
    (cl-stable-sort #'< :key #'cdr)
    (thread-last (mapcar #'car))))

(defun with-feature-middleware-handler (middleware)
  "Return the symbol for the function that handles given MIDDLEWARE, a symbol.
For example, if MIDDLEWARE is `split-args', then
`with-feature-middleware/split-args' is returned."
  (intern (format "with-feature-middleware/%S" middleware)))

;;;###autoload
(defmacro with-feature-defmiddleware
    (name order arglist &optional docstring &rest body)
  "Define and register a `with-feature' middleware.
NAME is an unquoted symbol, and ORDER is a number, possibly
computed at runtime. ARGLIST, DOCSTRING, and BODY are as in
`defun'.

Define a function of the form `with-feature-middleware/NAME', and
register the middleware in `with-feature-middleware-alist' with
the provided ORDER."
  (declare (indent defun))
  (unless (stringp docstring)
    (setq docstring nil)
    (setq body (cons docstring body)))
  `(progn
     (defun ,(with-feature-middleware-handler name) ,arglist
       ,@(when docstring
           (list docstring))
       ,@body)
     (map-put with-feature-middleware-alist ',name ,order)))

(defvar with-feature-middleware-features '(with-feature-core)
  "List of features that provide middleware for `with-feature'.
These features are all required when a `with-feature' form is
expanded.

If plugin authors have done their job correctly, the ordering of
this list does not matter. However, you never know. The features
will be required in the order they are specified here.")

;;;; Primary macro

;;;###autoload
(defmacro with-feature (feature &rest args)
  "After FEATURE is loaded, perform some actions based on ARGS."
  (dolist (feature with-feature-middleware-features)
    (require feature))
  (let ((state (cons feature args)))
    (dolist (middleware (with-feature-middlewares) state)
      (let ((handler (with-feature-middleware-handler middleware)))
        (setq state (funcall handler state))))))

;;;; Closing remarks

(provide 'with-feature)

;;; with-feature.el ends here

;; Local Variables:
;; outline-regexp: ";;;;* "
;; End:
